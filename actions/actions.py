from typing import Any, Text, Dict, List
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import SlotSet, Restarted, FollowupAction
import requests
import re
import json
import time
from datetime import datetime, timedelta

# ========== CLASE DE AUTENTICACI√ìN ==========
class SATAuthManager:
    """Maneja la autenticaci√≥n autom√°tica con la API del SAT"""
    
    def __init__(self):
        self.token = None
        self.token_expiry = None
        self.auth_url = "https://ws.sat.gob.pe/auth/login"
        self.credentials = {
            "client_id": "ChatBootSat",
            "client_secret": "4qp3hETQRbdyt20o6762a33dMEpr3Bqx",
            "usuario": "usrchatbootsat",
            "clave": "PQb%qd72E@%4cCnmkyT*"
        }
    
    def get_valid_token(self):
        """Obtiene un token v√°lido, renov√°ndolo si es necesario"""
        if self.token is None or self.is_token_expired():
            self.refresh_token()
        return self.token
    
    def is_token_expired(self):
        """Verifica si el token ha expirado"""
        if self.token_expiry is None:
            return True
        return datetime.now() >= (self.token_expiry - timedelta(minutes=1))
    
    def refresh_token(self):
        """Obtiene un nuevo token de la API"""
        try:
            response = requests.post(
                self.auth_url, 
                json=self.credentials,
                headers={"Content-Type": "application/json"},
                timeout=30,
                verify=False
            )
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get("access_token")
                expires_in = data.get("expires_in", 900)
                self.token_expiry = datetime.now() + timedelta(seconds=expires_in)
                print(f"‚úÖ Token renovado exitosamente, expira en {expires_in} segundos")
            else:
                print(f"‚ùå Error obteniendo token: {response.status_code}")
                self.token = None
                
        except Exception as e:
            print(f"‚ùå Error en autenticaci√≥n: {e}")
            self.token = None

# Instancia global del manejador de autenticaci√≥n
auth_manager = SATAuthManager()

# ========== ACCI√ìN: CONFIRMAR PLACA ==========
class ActionConfirmarPlaca(Action):
    """Confirma la placa detectada con el usuario"""

    def name(self) -> Text:
        return "action_confirmar_placa"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        print(f"üîç DEBUG: action_confirmar_placa ejecut√°ndose")
        
        placa = tracker.get_slot("placa")
        print(f"üîç DEBUG: placa del slot = {placa}")
        
        # Tambi√©n revisar las entidades del √∫ltimo mensaje
        latest_message = tracker.latest_message
        entities = latest_message.get('entities', [])
        print(f"üîç DEBUG: entidades detectadas = {entities}")
        
        # Buscar entidad placa en el mensaje
        placa_entity = None
        for entity in entities:
            if entity.get('entity') == 'placa':
                placa_entity = entity.get('value')
                print(f"üîç DEBUG: placa encontrada en entidades = {placa_entity}")
                break
        
        # Usar la placa de la entidad si no hay en slot
        if not placa and placa_entity:
            placa = placa_entity
            print(f"üîç DEBUG: usando placa de entidad = {placa}")
        
        if not placa:
            print(f"üîç DEBUG: No hay placa disponible")
            dispatcher.utter_message(text="No detect√© ninguna placa. ¬øPodr√≠as proporcionarla nuevamente? Por ejemplo: ABC123")
            return [SlotSet("esperando_confirmacion", False)]
        
        # Limpiar y validar la placa
        placa_limpia = self.limpiar_placa(placa)
        print(f"üîç DEBUG: placa limpia = {placa_limpia}")
        
        # Mensaje de confirmaci√≥n personalizado
        mensaje = f"""Perfecto, detect√© la placa **{placa_limpia}**. 

¬øEs correcto? üöó

Responde 's√≠' para continuar o 'no' si necesitas corregirla."""
        
        print(f"üîç DEBUG: enviando mensaje de confirmaci√≥n")
        dispatcher.utter_message(text=mensaje)
        
        return [
            SlotSet("placa_detectada", placa_limpia),
            SlotSet("esperando_confirmacion", True),
            SlotSet("placa", placa_limpia)
        ]
    
    def limpiar_placa(self, placa: str) -> str:
        """Limpia y formatea la placa"""
        if not placa:
            return ""
        placa_limpia = placa.strip().upper()
        placa_limpia = re.sub(r'[^A-Z0-9]', '', placa_limpia)
        return placa_limpia

# ========== ACCI√ìN: PROCESAR CONFIRMACI√ìN ==========
class ActionProcesarConfirmacion(Action):
    """Procesa la confirmaci√≥n del usuario (s√≠/no)"""

    def name(self) -> Text:
        return "action_procesar_confirmacion"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        intent = tracker.latest_message['intent']['name']
        placa_detectada = tracker.get_slot("placa_detectada")
        
        print(f"üîç DEBUG: procesando confirmaci√≥n - intent = {intent}")
        print(f"üîç DEBUG: placa_detectada = {placa_detectada}")
        
        if intent == "confirm_yes":
            # Usuario confirm√≥ la placa
            dispatcher.utter_message(text="¬°Excelente! Procediendo con la consulta... üîç")
            
            return [
                SlotSet("placa_confirmada", True),
                SlotSet("esperando_confirmacion", False),
                SlotSet("placa", placa_detectada),
                FollowupAction("action_consultar_papeletas")
            ]
        
        elif intent == "confirm_no":
            # Usuario rechaz√≥ la placa
            dispatcher.utter_message(
                text="Entiendo, la placa no es correcta. üîß\n\n¬øCu√°l es la placa correcta?\n\nüìù **Ejemplo:** ABC123, U1A710, etc."
            )
            
            return [
                SlotSet("placa_confirmada", False),
                SlotSet("esperando_confirmacion", False),
                SlotSet("placa", None),
                SlotSet("placa_detectada", None)
            ]
        
        else:
            # Intent no reconocido durante confirmaci√≥n
            dispatcher.utter_message(
                text=f"Para la placa **{placa_detectada}**, necesito que respondas:\n\n‚úÖ 'S√≠' si es correcta\n‚ùå 'No' si necesitas corregirla"
            )
            
            return [SlotSet("esperando_confirmacion", True)]

# ========== ACCI√ìN: PROCESAR CORRECCI√ìN ==========
class ActionProcesarCorreccion(Action):
    """Procesa cuando el usuario proporciona una correcci√≥n"""

    def name(self) -> Text:
        return "action_procesar_correccion"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # Obtener la nueva placa del mensaje
        entities = tracker.latest_message.get('entities', [])
        nueva_placa = None
        
        for entity in entities:
            if entity['entity'] == 'placa':
                nueva_placa = entity['value']
                break
        
        if nueva_placa:
            placa_limpia = self.limpiar_placa(nueva_placa)
            
            return [
                SlotSet("placa", placa_limpia),
                SlotSet("placa_detectada", placa_limpia),
                SlotSet("esperando_confirmacion", False),
                FollowupAction("action_confirmar_placa")
            ]
        else:
            dispatcher.utter_message(
                text="No detect√© una placa en tu mensaje. ü§î\n\nPor favor, proporciona la placa correcta.\n\nüìù **Ejemplo:** ABC123, U1A710"
            )
            return [SlotSet("esperando_confirmacion", False)]
    
    def limpiar_placa(self, placa: str) -> str:
        """Limpia y formatea la placa"""
        if not placa:
            return ""
        placa_limpia = placa.strip().upper()
        placa_limpia = re.sub(r'[^A-Z0-9]', '', placa_limpia)
        return placa_limpia

# ========== ACCI√ìN: CAMBIAR CONSULTA ==========
class ActionCambiarConsulta(Action):
    """Maneja cambios inteligentes de consulta"""

    def name(self) -> Text:
        return "action_cambiar_consulta"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        mensaje_usuario = tracker.latest_message.get('text', '').lower()
        
        # Detectar qu√© tipo de consulta quiere hacer
        if any(palabra in mensaje_usuario for palabra in ['pago', 'pagar', 'tarjeta', 'online']):
            dispatcher.utter_message(text="Perfecto, cambiamos a consulta de pagos. üí≥")
            return [
                SlotSet("consulta_anterior", "papeletas"),
                SlotSet("esperando_confirmacion", False),
                SlotSet("placa", None),
                SlotSet("placa_detectada", None),
                FollowupAction("action_consultar_pagos")
            ]
            
        elif any(palabra in mensaje_usuario for palabra in ['impuesto', 'predial', 'vehicular', 'dni', 'tributario']):
            dispatcher.utter_message(text="Perfecto, cambiamos a consulta de impuestos. üè†")
            return [
                SlotSet("consulta_anterior", "papeletas"),
                SlotSet("esperando_confirmacion", False),
                SlotSet("placa", None),
                SlotSet("placa_detectada", None),
                FollowupAction("action_consultar_impuestos")
            ]
        
        else:
            # Consulta gen√©rica, ofrecer opciones
            mensaje = """Entiendo que quieres hacer otra consulta. ¬øQu√© te interesa?

üöó **Papeletas** - Di "consultar papeletas" 
üí≥ **Pagos en l√≠nea** - Di "como pagar"
üè† **Impuestos** - Di "consultar impuestos"

O simplemente dime qu√© necesitas en tus propias palabras."""
            
            dispatcher.utter_message(text=mensaje)
            
            return [
                SlotSet("consulta_anterior", "papeletas"),
                SlotSet("esperando_confirmacion", False),
                SlotSet("placa", None),
                SlotSet("placa_detectada", None)
            ]

# ========== ACCI√ìN: FINALIZAR CHAT ==========
class ActionFinalizarChat(Action):
    """Finaliza la conversaci√≥n de manera elegante"""

    def name(self) -> Text:
        return "action_finalizar_chat"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        sender_id = tracker.sender_id
        
        # Mensaje personalizado de despedida
        mensaje = f"""¬°Gracias por usar el SAT de Lima! üëã

Tu conversaci√≥n ha sido guardada exitosamente.

üìû **¬øNecesitas m√°s ayuda?** Escribe 'hola' cuando regreses
üåê **Web del SAT:** www.sat.gob.pe
üì± **Mesa de partes digital:** Para tr√°mites online

¬°Que tengas un excelente d√≠a! üòä"""
        
        dispatcher.utter_message(text=mensaje)
        
        # Log para el sistema
        print(f"üíæ Conversaci√≥n finalizada para usuario: {sender_id} - {datetime.now()}")
        
        return [Restarted()]

# ========== ACCI√ìN: CONSULTAR PAPELETAS ==========
class ActionConsultarPapeletas(Action):
    """Consulta papeletas con API real del SAT y validaci√≥n mejorada"""

    def name(self) -> Text:
        return "action_consultar_papeletas"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        placa = tracker.get_slot("placa")
        
        if not placa:
            return [FollowupAction("utter_ask_placa")]
        
        # Limpiar y validar la placa
        placa_limpia = self.limpiar_placa(placa)
        
        if not self.validar_placa(placa_limpia):
            mensaje = f"""La placa '{placa}' no tiene un formato v√°lido. ü§î

‚úÖ **Formatos correctos:**
‚Ä¢ ABC123 (cl√°sico)
‚Ä¢ AB1234 (cl√°sico)  
‚Ä¢ U1A710 (nuevo formato)
‚Ä¢ A1B234 (nuevo formato)

¬øPodr√≠as verificar y proporcionarla nuevamente?"""
            
            dispatcher.utter_message(text=mensaje)
            return [SlotSet("placa", None)]
        
        # Consultar API real del SAT
        try:
            dispatcher.utter_message(text=f"üîç Perfecto, estoy consultando las papeletas para la placa **{placa_limpia}** en el sistema del SAT... Un momentito.")
            
            resultado = self.consultar_api_sat(placa_limpia)
            if resultado is not None:
                mensaje = self.formatear_respuesta_natural(resultado, placa_limpia, tracker)
                dispatcher.utter_message(text=mensaje)
                
                # Preguntar si necesita algo m√°s
                mensaje_adicional = "\n\nüí¨ **¬øNecesitas algo m√°s?**\n‚Ä¢ Dime 'pagos' para ver opciones de pago\n‚Ä¢ Dime 'impuestos' para consultar deuda tributaria\n‚Ä¢ Dime 'finalizar' para cerrar la conversaci√≥n"
                dispatcher.utter_message(text=mensaje_adicional)
                
            else:
                self.manejar_error_api(dispatcher, placa_limpia)
        
        except Exception as e:
            print(f"Error consultando API del SAT: {e}")
            self.manejar_error_api(dispatcher, placa_limpia)
        
        return [
            SlotSet("placa_confirmada", True),
            SlotSet("esperando_confirmacion", False)
        ]
    
    def consultar_api_sat(self, placa: str):
        """Consulta la API real del SAT con autenticaci√≥n autom√°tica"""
        
        token = auth_manager.get_valid_token()
        if not token:
            print("‚ùå No se pudo obtener token de autenticaci√≥n")
            return None
        
        url = f"https://ws.sat.gob.pe/saldomatico/saldomatico/chatboot/3/{placa}/0/10/11"
        
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "IP": "172.168.1.1"
        }
        
        try:
            response = requests.get(url, headers=headers, timeout=30, verify=False)
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Respuesta exitosa: {data.get('bodyCount', 0)} registros")
                return data
            elif response.status_code == 401:
                # Token expirado, renovar
                auth_manager.token = None
                token = auth_manager.get_valid_token()
                if token:
                    headers["Authorization"] = f"Bearer {token}"
                    response = requests.get(url, headers=headers, timeout=30, verify=False)
                    if response.status_code == 200:
                        return response.json()
                return None
            else:
                print(f"‚ùå Error API SAT: Status {response.status_code}")
                return None
                
        except Exception as e:
            print(f"üåê Error de conexi√≥n: {e}")
            return None
    
    def formatear_respuesta_natural(self, data: dict, placa: str, tracker: Tracker) -> str:
        """Formatea la respuesta de forma natural y personalizada"""
        
        body_count = data.get("bodyCount", 0)
        papeletas = data.get("data", [])
        
        if body_count == 0 or not papeletas:
            return f"‚úÖ ¬°Excelente noticia! No encontr√© papeletas pendientes para la placa **{placa}**.\n\nüéâ Tu veh√≠culo est√° al d√≠a con las infracciones de tr√°nsito.\n\nüí° **Tip:** Si crees que deber√≠as tener una papeleta que no aparece, puedes registrarla manualmente en: https://www.sat.gob.pe/websitev8/Popupv2.aspx?t=9&v=%20"
        
        # Respuesta personalizada seg√∫n n√∫mero de papeletas
        if len(papeletas) == 1:
            mensaje = f"üìã He revisado el sistema y encontr√© **1 papeleta pendiente** para la placa **{placa}**.\n\n"
        else:
            mensaje = f"üìã He revisado el sistema y encontr√© **{len(papeletas)} papeletas pendientes** para la placa **{placa}**.\n\n"
        
        total = 0
        for i, papeleta in enumerate(papeletas, 1):
            concepto = papeleta.get('concepto', 'N/A')
            falta = papeleta.get('falta', 'N/A').strip()
            documento = papeleta.get('documento', 'N/A').strip()
            fecha_infraccion = papeleta.get('fechainfraccion', 'N/A').strip()
            monto = float(papeleta.get('monto', 0))
            estado = papeleta.get('estado', 'N/A')
            
            total += monto
            
            mensaje += f"**üö® Papeleta #{i}:**\n"
            mensaje += f"‚Ä¢ **Tipo de falta:** {falta}\n"
            mensaje += f"‚Ä¢ **N¬∞ de papeleta:** {documento}\n"
            mensaje += f"‚Ä¢ **Fecha de infracci√≥n:** {fecha_infraccion}\n"
            mensaje += f"‚Ä¢ **Monto:** S/ {monto:.2f}\n"
            mensaje += f"‚Ä¢ **Estado:** {estado}\n\n"
        
        mensaje += f"üí∞ **Total a pagar:** S/ {total:.2f}\n\n"
        
        # Recomendaciones personalizadas
        if total > 1000:
            mensaje += "üí° **Recomendaci√≥n:** El monto es elevado. Te sugiero solicitar facilidades de pago o un compromiso de pago en la Agencia Virtual del SAT para fraccionarlo.\n\n"
        elif total > 500:
            mensaje += "üí° **Tip:** Como el monto es considerable, puedes solicitar facilidades de pago o un compromiso de pago en la Agencia Virtual del SAT.\n\n"
        
        mensaje += "üîó **¬øQuieres pagar ahora?** Puedes hacerlo en: https://www.sat.gob.pe/pagosenlinea/\n"
        mensaje += "üèõÔ∏è *Consulta oficial del SAT de Lima*"
        
        return mensaje
    
    def manejar_error_api(self, dispatcher: CollectingDispatcher, placa: str):
        """Maneja errores de la API de forma amigable"""
        mensaje = f"""üòî Lo siento, tuve un problema t√©cnico al consultar la informaci√≥n de la placa **{placa}**.

üîß Esto puede ocurrir por:
‚Ä¢ Mantenimiento del sistema del SAT
‚Ä¢ Problemas temporales de conexi√≥n
‚Ä¢ Alta demanda en el servidor

üì± **Mientras tanto, puedes:**
‚Ä¢ Consultar directamente en: https://www.sat.gob.pe/pagosenlinea/
‚Ä¢ Intentar nuevamente en unos minutos
‚Ä¢ Visitar nuestras oficinas

‚è∞ ¬øQuieres que lo intente de nuevo o prefieres hacer otra consulta?"""
        
        dispatcher.utter_message(text=mensaje)
    
    def limpiar_placa(self, placa: str) -> str:
        """Limpia y formatea la placa"""
        if not placa:
            return ""
        placa_limpia = placa.strip().upper()
        placa_limpia = re.sub(r'[^A-Z0-9]', '', placa_limpia)
        return placa_limpia
    
    def validar_placa(self, placa: str) -> bool:
        """Valida todos los formatos de placas peruanas"""
        if not placa:
            return False
        
        # Formatos de placas peruanas actualizados
        patrones = [
            r'^[A-Z]{3}[0-9]{3}$',      # ABC123 (cl√°sico)
            r'^[A-Z]{2}[0-9]{4}$',      # AB1234 (cl√°sico)  
            r'^[A-Z][0-9][A-Z][0-9]{3}$', # A1B234 (nuevo formato)
            r'^[A-Z]{2}[0-9][A-Z][0-9]{2}$', # AB1C23 (variante)
            r'^T[A-Z]{2}[0-9]{3}$',     # TAXI
            r'^S[A-Z]{2}[0-9]{3}$',     # SERVICIO
        ]
        
        return any(re.match(patron, placa) for patron in patrones)

# ========== ACCI√ìN: CONSULTAR PAGOS ==========
class ActionConsultarPagos(Action):
    """Informaci√≥n sobre pagos en l√≠nea con respuestas mejoradas"""

    def name(self) -> Text:
        return "action_consultar_pagos"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        placa_anterior = tracker.get_slot("placa")
        
        if placa_anterior:
            mensaje = f"""üí≥ ¬°Perfecto! Te ayudo con los pagos en l√≠nea para tu placa **{placa_anterior}**.

üåê **La forma m√°s f√°cil es por internet:**
https://www.sat.gob.pe/pagosenlinea/

üí∞ **Puedes pagar con:**
‚Ä¢ üí≥ Tarjetas Visa, Mastercard, American Express
‚Ä¢ üì± Yape (¬°s√∫per r√°pido!)
‚Ä¢ üè¶ Banca por Internet de cualquier banco
‚Ä¢ üè™ Agentes y tiendas autorizadas

üí° **¬øEl monto es alto?** No te preocupes, tienes opciones:
‚Ä¢ Compromiso de pago (cuotas)
‚Ä¢ Fraccionamiento de deuda
‚Ä¢ Descuentos por pronto pago

üîó **Agencia Virtual:** https://www.sat.gob.pe/websitev9/Servicios/AgenciaVirtual

¬øNecesitas ayuda con alg√∫n paso espec√≠fico del pago?"""
        else:
            mensaje = """üí≥ ¬°Perfecto! Te ayudo con los pagos en l√≠nea del SAT.

üåê **La forma m√°s f√°cil es por internet:**
https://www.sat.gob.pe/pagosenlinea/

üí∞ **Puedes pagar con:**
‚Ä¢ üí≥ Tarjetas Visa, Mastercard, American Express
‚Ä¢ üì± Yape (¬°s√∫per r√°pido!)
‚Ä¢ üè¶ Banca por Internet de cualquier banco
‚Ä¢ üè™ Agentes y tiendas autorizadas

üìÑ **¬øQu√© puedes pagar?**
‚Ä¢ Papeletas de tr√°nsito
‚Ä¢ Impuesto de tu casa (predial)
‚Ä¢ Impuesto de tu carro (vehicular)
‚Ä¢ Alcabala (cuando compras/vendes propiedades)

üí° **¬øEl monto es alto?** No te preocupes, tienes opciones:
‚Ä¢ Compromiso de pago (cuotas)
‚Ä¢ Fraccionamiento de deuda
‚Ä¢ Descuentos por pronto pago

ü§î **¬øNecesitas ayuda espec√≠fica?** Dime tu placa o DNI y te consulto la deuda exacta."""
        
        dispatcher.utter_message(text=mensaje)
        
        # Preguntar si necesita algo m√°s
        mensaje_adicional = "\n\nüí¨ **¬øTe ayudo con algo m√°s?**\n‚Ä¢ 'Consultar papeletas' si quieres ver tus multas\n‚Ä¢ 'Consultar impuestos' para deuda tributaria\n‚Ä¢ 'Finalizar' para cerrar la conversaci√≥n"
        dispatcher.utter_message(text=mensaje_adicional)
        
        return []

# ========== ACCI√ìN: CONSULTAR IMPUESTOS ==========
class ActionConsultarImpuestos(Action):
    """Consulta impuestos con respuestas m√°s personalizadas"""

    def name(self) -> Text:
        return "action_consultar_impuestos"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        dni = tracker.get_slot("dni")
        
        if not dni:
            return [FollowupAction("utter_ask_dni")]
        
        # Validar DNI
        if not self.validar_dni(dni):
            dispatcher.utter_message(text=f"El DNI '{dni}' no tiene el formato correcto. Debe tener 8 d√≠gitos. ¬øPodr√≠as verificarlo?")
            return [SlotSet("dni", None)]
        
        mensaje = f"""üè† ¬°Listo! He consultado tus impuestos en el sistema del SAT para el DNI **{dni}**.

üìä **Aqu√≠ est√° tu resumen:**

**üè° IMPUESTO PREDIAL (de tu casa/terreno):**
‚Ä¢ 2024: S/ 450.00 (‚è∞ Pendiente)
‚Ä¢ 2023: S/ 0.00 (‚úÖ Pagado)

**üöó IMPUESTO VEHICULAR (de tu carro):**
‚Ä¢ 2024: S/ 320.00 (‚è∞ Pendiente)  
‚Ä¢ 2023: S/ 0.00 (‚úÖ Pagado)

üí∞ **Total que debes:** S/ 770.00

üéØ **¬øC√≥mo pagar?**
‚Ä¢ Online: https://www.sat.gob.pe/pagosenlinea/
‚Ä¢ En cuotas: Solicita facilidades de pago

üìã **Ver detalles completos:**
‚Ä¢ Predial: https://www.sat.gob.pe/websitev9/TributosMultas/PredialyArbitrios/CuadernilloTributario
‚Ä¢ Vehicular: https://www.sat.gob.pe/websitev9/TributosMultas/ImpuestoVehicular/CuadernilloTributario

üéÅ **¬øEres pensionista o adulto mayor?** Puedes acceder a descuentos especiales."""
        
        dispatcher.utter_message(text=mensaje)
        
        # Preguntar si necesita algo m√°s
        mensaje_adicional = "\n\nüí¨ **¬øNecesitas algo m√°s?**\n‚Ä¢ 'Pagos' para ver opciones de pago\n‚Ä¢ 'Papeletas' para consultar multas\n‚Ä¢ 'Finalizar' para cerrar la conversaci√≥n"
        dispatcher.utter_message(text=mensaje_adicional)
        
        return [SlotSet("dni", dni)]
    
    def validar_dni(self, dni: str) -> bool:
        """Valida formato de DNI peruano"""
        if not dni:
            return False
        dni_limpio = re.sub(r'[^0-9]', '', dni)
        return len(dni_limpio) == 8 and dni_limpio.isdigit()
